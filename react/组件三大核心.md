# React 组件三大核心

## 一. state

### 描述：state 是组件对象最重要的属性，值是对象（可以包含多个 key-value 的组合）。组件被称为“状态机”，通过更新组件的 state 来更新对应的页面显示（重新渲染组件）

```js
    // 创建组件
    class Weather extends React.Component {
        // 构造器调用几次？ —— 1次
        constructor(props){
            super(props)
            this.state = { isHost:false }
            this.changeWeather = this.changeWeather.bind(this)
            // 通过bind方法来改变changeWeather中的this指向问题
        }

        // render调用几次？ —— 1+n次 1是初始化 n是状态更新的次数
        render() {
            return <h1 onClick={this.changeWeather}>今天天气{this.state.isHost?'炎热' : '凉爽'}</h1>
        }

        // changeWeather放在哪里？ ——Weather的原型对象上，供实例使用。
        // 由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
        // changeWeather调用几次？ —— 点击几次就调用几次

        changeWeather() {
            // 如果直接通过 onClick 赋值调用，那么函数体中的this指向并不是实例对象，而且开启了严格模式的undefined (this === 'undefined')
            let { isHost } = this.state
            // 严重注意：状态必须通过setState进行更改，且更新是一种合并，并不是替换。
            this.setState({isHost : !isHost})
        }
    }
    // 渲染组件到页面
    ReactDOM.render(<Weather onClick={this.changeWeather}/>,document.getElementById('test'))
```

```js
    // 简化上述代码

    class Weather extends React.Component {
        state = {
            isHost : false,
            wind : '微风'
        }
        render() {
            return <h1 onClick={this,changeWeather}>今天天气{this.state.isHost?'炎热' : '凉爽'}</h1>
        }
        changeWeather = ()=>{
            let { isHost } = this.state
            this.setState({
                isHost : !isHost
            })
        }
    }
    ReactDOM.render(<Weather onClick={this.changeWeather}/>,document.getElementById('test'))
```

## <p></p>

#### 注意：

> 1.组件中 render 方法中的 this 为组件实例对象
>
> 2.组件自定义的方法中 this 为 undefined，如何解决？
>
> - a.强制绑定 this,通过函数对象的 bind 方法。
> - b.箭头函数
>
>  3.状态数据，不能直接修改或者更新 

## <p></p>

## 二. props

### 描述： 每个组件对象都会有个props(properties的简写)属性，且组件标签的所有属性都保存在props中。通过标签属性从组件外向组件内传递变化的数据，注意：组件内部不要修改props属性。

```js
一、普通传递

    // 创建组件
    class Person extends React.Component{
        render() {
            const { name, age, sex} = this.props
            return(
                <ul>
                    <li>姓名：{name}</li>
                    <li>性别：{sex}</li>
                    <li>年龄：{age+1}</li>
                </ul>
            )
        }
    }

    // 渲染组件到页面
    ReactDOM.render(<Person name="tom" age={19} sex="男"/>, document.getElementById('test'))

```
```js
二、接口赋值的方式传递
    
    // 创建组件
    class Person extends React.Component{
        render() {
            const {name,age,sex} = this.props
            return(
                <ul>
                    <li>姓名：{name}</li>
                    <li>性别：{sex}</li>
                    <li>年龄：{age+1}</li>
                </ul>
            )
        }
    }

    // 渲染组件到页面
    const p = { name:"老王" , sex:"男" , age:19 }
    ReactDOM.render(<Person {...p}/>, document.getElementById('test'))

```
```js
三、对标签属性进行类型、必要性的限制

    //  创建组件
    class Person extends React.Component{
        render(){
            const {name,age,sex} = this.props
            return(
                <ul>
                    <li>姓名：{name}</li>
                    <li>性别：{sex}</li>
                    <li>年龄：{age+1}</li>
                </ul>
            )
           
        }
    }

    // 对标签属性进行类型、必要性的限制
    Person.propTypes = {
        name: PropType.string.isRequired, // 限制name必传，且为字符串
        sex: PropType.string, // 限制sex为字符串
        age: PropType.number, // 限制age为数字
        speack: PropType.func // 限制speack为方法
    }

    // 对标签属性初始化设置
    Person.defaultProps = {
        sex: '男',
        age: 18
    }

    // 渲染组件到页面
    const p = { name:"老王" , sex:"男" , age:19 }

    function speack (){
        console.log('说话')
    }

    ReactDOM.render(<Person { ...p, speack, }/>, document.getElementById('test'))
```
```js
四、对标签属性进行类型、必要性的限制进行简写
    //  创建组件
    class Person extends React.Component{
        render(){
            const {name,age,sex} = this.props
            return(
                <ul>
                    <li>姓名：{name}</li>
                    <li>性别：{sex}</li>
                    <li>年龄：{age+1}</li>
                </ul>
            )
            
        },
        static propsType = {
            name: PropType.string.isRequired, // 限制name必传，且为字符串
            sex: PropType.string, // 限制sex为字符串
            age: PropType.number, // 限制age为数字
            speack: PropType.func // 限制speack为方法
        }
        static defaultProps = {
            sex: '男',
            age: 18
        }
    }
    // 渲染组件到页面
    const p = { name:"老王" , sex:"男" , age:19 }

    function speack (){
        console.log('说话')
    }

    ReactDOM.render(<Person { ...p, speack, }/>, document.getElementById('test'))

```

## <p></p>

## 三. refs

### 描述：组件内的标签可以自定义ref属性来标识自己。
### ref的三中表达方式

```js
    一、字符串形式的ref(基本上已经废弃使用)
    // 创建组件
    class Demo extends React.Component{
        showData = ()=>{
            const { input1 } = this.refs
            alert(input1.value)
        }
        render(){
            return(
                <div>
                    <imput ref='input1' type='text' placeholder='点击按钮提示数据' />
                    <button onClick={this.showData} >点击</button>
                </div>
            )
        }
    }
    // 渲染组件
    ReactDOM.render(<Demo/>,document.getElementById('test'))
```

```js
    二、回调函数的ref
    class Demo extends React.Component {
        // 内联形式
        showData = ()=> {
            alert(this.input1.value)
        }
        // 类绑定形式
        saveInput = (c) => {
            this.input2 = c
        }
        render(){
            return(
                <div>
                    <input ref={(c) =>this.input1 = c} type='text' placeholder='点击按钮提示数据' />
                    <button onClick={this.showData}>点击</button>
                    <input ref={this.saveInput} type='text' placeholder='点击按钮提示数据' />
                </div>
            )
        }
    }
    ReactDOM.render(<Demo />,document.getElementById('test'))
```
## <p></p>

### 描述：React将在组件挂载时，如果使用ref内联形式的来调用ref回调函数并传入DOM元素，会使得当卸载完成后再调用它时候ref会先传入null，然后在componentDidMount 或 componentDidUpdate 触发前，React会保证refs一定是最新的。因此在使用回调函数的ref时候，该回调会被调用两次，一次为null，另一次为函数调用的标签。

## <p></p>

```js
    三、createRef 创建ref容器
     class Demo extends React.Component {
        myRef = React.createRef()
        showData = ()=> {
            alert(this.input1.value)
        }
        render(){
            return(
                <div>
                    <input ref={this.myRef} type='text' placeholder='点击按钮提示数据'/>
                    <button onClick={this.showData}>点击</button>
                </div>
            )
        }
    }
    ReactDOM.render(<Demo />,document.getElementById('test'))

```

