# React 面向组件编程

## 一. 组件

### 1. 什么是组件

#### &nbsp;&nbsp;&nbsp;&nbsp;用来实现局部功能的代码和资源的集合称为组件

## <p></p>

### 2.为什么要使用组件

#### &nbsp;&nbsp;&nbsp;&nbsp;一个界面的功能更复杂

## <p></p>

### 3.使用组件的作用

#### &nbsp;&nbsp;&nbsp;&nbsp;复用编码，简化项目编码，提高运行效率

## <p></p>

## 二.组件的定义格式

## <p></p>

### 1.函数化组件

#### &nbsp;&nbsp;&nbsp;&nbsp; 通过函数的形式来定义组件

```
    // 1.创建函数组件
    function MyComponent () {
        return <h2>我是用函数定义的组件（适用于【简单组件】的定义）</h2>
    }

    // 2.渲染组件到页面
    ReactDOM.render(<MyComponent/>,document.getElementById('test'))
```

#### 执行了 ReactDOM.ReactDOM.render<MyComponent/> .... 之后，发生了什么？

#### 1.React 会解析组件标签，找到对应的 MyComponent 组件。

#### 2.发现组件是使用函数定义的，随后调用该函数，将返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中。

## <p></p>

### 2.类式组件

## <p></p>

#### 1.类的例子

```js
    // 创建一个Person类
    class Person(){
        constructor(name,age){
            // 构造器中的this是谁？ —— 类的实例对象
            this.name = name
            this.age = age
        }
        // 一般方法
        speak(){
            // speak方法放在哪里？ —— 类的原型对象上，供实例使用
            // 通过Person实例调用speak时，speak中的this就是Person实例。总称为：谁构造出的实例，谁调用，this指向就是谁
            console.log(`我叫${this.name},我的年龄是${this.age}`)
        }
    }
    const p1 = new Person('张三',15)

    // 创建一个Student类，继承于Person类
    class Student extends Person {
        constructor(name,age,grade){
            super(name,age)
            this.grade = grade
        }
        // 重写方法
        speak(){
            console.log(`我叫${this.name}，我的年龄是${this.age}`，我的年级是${this.grade})
        }
    }
    const s1 = new Student('小米',19,'高三')
```

#### &nbsp;&nbsp;&nbsp;&nbsp; 总结：

> 1.类中的构造器不是必须写的，如果实例对象要进行数据的初始化操作时候，需要添加上 constructor 构造器来接收参数
>
> 2.如果 A 类继承了 B 类，且 A 类中写了构造器。那么 A 类构造器中的 super 是必须要调用的。
>
> 3.类中所定义的方法，都是放在类的原型对象上，供实例去使用。

## <p></p>

#### 2.类式组件的例子

```js
    // 1.创建类式组件
    class MyComponent extends React.Component {
        // render是放在哪里的？ —— MyComponent 的原型对象上，供实例使用。
        // render中的this是谁？ —— MyComponent 的实例对象 MyComponnent 组件实例对象
        render() {
            return <h2>我是用类定义的组件（适用于【复杂组件】的定义）</h2>
        }
    }

    // 2.渲染组件到页面
    ReactDOM.render(<MyComponent/>,doucument.getElementById('test'))
```

#### &nbsp;&nbsp;&nbsp;&nbsp; 总结： 执行了 ReactDOM.render.....之后发生了什么？

> 1.React 解析组件标签，找到对于的 MyComponent 组件。
>
> 2.发现组件是使用类定义的，随后会自动 new 出来该类的实例，并通过该实例调用到原型上的 render 方法。
>
> 3.将 render 返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中。

## 三、组件的事件处理

## <p></p>

> 1.通过onXXX属性指定事件处理函数（注意大小写）
> + React 使用的是自定义（合成）事件，而不是使用的原生的DOM事件
> + React 中的事件是通过事件委托的方式处理的（委托给组件最外层的元素）
> 
> 2.通过event.target得到发生事件的DOM元素对象

## <p></p>

## 四、受控组件和非受控组件
### 通过表单收集数据的案例来说明
```js
    // 一、非受控组件 (现用现取)
    class Login extends React.Component {
        handleSubmit = (event) =>{
            event.preventDefault() // 阻止表单提交
            const { userName, passWord } = this
            alert(`你输入的用户名是：${userName.vaule}，你输入的密码是：${passWord.vaule}`)
        }
        render(){
            return(
                <form onSubmit={this.handleSubmit}>
                    <input  type='text' name='username' ref={ c => this.userName = c } />
                    <input  type='password' ref={ c => this.passWord = c }name='password' />
                    <button>登录</button>
                </form>
            )
        }
    }
    ReactDOM.render(<Login/>,document.getElementById('test'))
```
```js
    // 二、受控组件(随着输入来维护状态)
    class Login extends React.Component {
        state = {
            userName : '',
            passWord : ''
        }
        handleSubmit = (event) => {
            event.preventDefault() // 阻止表单提交
            const { userName, passWord } = this.state
            alert(`你输入的用户名是：${userName}，你输入的密码是：${passWord}`)
        }
        saveUserName = (event) => {
            this.setState({ userName:event.target.value })
        }
        savePassWord = (event) => {
            this.setState({ passWord:event.target.value })
        }
        render(){
            return(
                <form onSubmit={this.handleSubmit}>
                    <input  type='text' name='username' onChange={this.saveUserName} />
                    <input  type='password' onChange={this.savePassWord}name='password' />
                    <button>登录</button>
                </form>
            )
        }
    }
    ReactDOM.render(<Login/>,document.getElementById('test'))
```


## 五、高阶函数和函数柯里化

## <p></p>

### 高阶函数 : 如果一个函数符合下面两种规范中的任何一个，那该函数就是高阶函数。

> 1.若A函数，接收的参数是一个函数，那么A就可以称为高阶函数
> 
> 2.若A函数，调用的返回值依然是一个函数，那么A可以称之为高阶函数。
> 
> 常见的高阶函数有：Promise、setTimeout、数组的多种方法

## <p></p>

### 函数柯里化：通过函数吊影继续返回函数的方式，实现多次接受参数最后统一处理的函数编码形式。

```js
    class Login extends React.Component {
        state = {
            userName : '',
            passWord : ''
        }
        handleSubmit = (event) => {
            event.preventDefault() // 阻止表单提交
            const { userName, passWord } = this.state
            alert(`你输入的用户名是：${userName}，你输入的密码是：${passWord}`)
        }
        // 应用了高阶函数和函数柯里化
        saveData = (type) => {
            return (event) => {
                this.setState({ [type] :event.target.value })
            }
        }
        render(){
            return(
                <form onSubmit={this.handleSubmit}>
                    <input  type='text' name='username' onChange={this.saveData('userName')} />
                    <input  type='password' onChange={this.saveData('passName')}name='password' />
                    <button>登录</button>
                </form>
            )
        }
    }
    ReactDOM.render(<Login/>,document.getElementById('test'))
```

## 六、关于react和vue中的循环遍历页面DOM元素遇到的问题

## <p></p>

### 1.react或vue的key有什么作用？（key中的内部原理是什么）
### 2.为什么列表遍历时，key最好不要用index

## <p></p>

虚拟DOM中key的作用：
> + 简单来说：key是虚拟DOM对象的标识，在更新显示时key起到了极其重要的作用。
> + 详细来说：当状态中的数据发生改变的时候，react会根据『新数据 』生成『 新的虚拟DOM 』,随后React进行『新虚拟DOM 』与『 旧虚拟DOM 』的diff比较，比较规则如下：
> > + a. 旧虚拟DOM中找到了与新虚拟DOM相同的key：
> > > + (1).若虚拟DOM中内容没变，直接使用之前的真实DOM
> > > + (2).若虚拟DOM内容发生变化，则新成新的DOM，随后替换掉页面之前的真实DOM
> > + b. 旧虚拟DOM中未找到与新虚拟DOM相同的key：
> > > + 根据数据创建新的虚拟DOM，随后渲染到页面。

## <p></p>

用index作为key可能会引发的问题：
> + 若对数据进行：逆序添加、逆序删除等破坏顺序操作：会产生没有必要的真实DOM更新——界面效果没问题，但效率低
> + 如果结构中还包含输入类的DOM：会产生错误DOM更新——界面有问题
> + 注意！如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于的展示，使用index作为key是没有问题的。

## <p></p>

开发中如果选择key？
> + 最好使用每条数据的唯一标识作为key，例如id,身份证号码,手机号,学好等为一值。
> + 如果确定了知识简单的数据展示，那么可以使用index来作为key

