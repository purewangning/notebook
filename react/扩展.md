# React 扩展

## 1. setState

### setState更新的两种写法

```
    (1). setState(stateChange, [callback] ———— 对象式的setState)
        1.setStateChange为状态改变对象(该对象可以体现出状态的更改)
        2.callback是可选的回调函数，它在状态更新完毕、界面也更新后(render调用后)才会被调用

    (2). setState(updater,[callback]) ———— 函数式的setState
        1.updater为返回stateChange对象的函数。
        2.updater可以接收到state和props。
        3.callback是可选的回调函数，它在状态更新、界面也更新后(render调用后)才会被调用
```
总结：
- 对象式的setState是函数式的setState的简写方式(语法糖)
  
- 使用规则

    - 如果新状态不依赖于原状态 ===> 使用对象方式

    - 如果新状态依赖于原状态 ===> 使用函数方式

    - 如果需要在 ```setState()``` 执行后获取最新的状态数据，要在第二个callback函数中获取

-----

## 2. lazyLoad（路由懒加载）

### 路由组件的lazyLoad

``` js
    // 1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包
    
    import react ,{ lazy, Suspense } from 'React'
    const Login = lazy(() => import('xxxxx'))

    // 2.通过<Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面（该组件不能使用路由懒加载进行引入）

    <Suspense>
        <Routes>
            <Route path='/xxxx' element={<xxx></xxx>}></Route>
            <Route path='*' element={<Nagive to='/xxx'/>}></Route>
        </Routes>
    </Suspense>
```

------

## 3.Hooks

### 1. React Hook / Hooks是什么？

- Hook是React 16.8.0版本新增的新特性/新语法

- 可以让你的函数式组件可以使用组件式组件的一些特定类型和方法，例如 state 和 生命周期。

### 2. 三个常用的Hook

- State Hook : React.useState()

- Effect Hook : React.useEffect()

- Ref Hook : React.useRef()

### 3. State Hook

- State Hook 让函数组件也可以有state状态，并进行状态数据的读写操作

- 语法：```const [xxx, setXxx] = React.useState(initValue) ```

- useState( ) 说明：
  - 参数：第一次初始化指定的值在内部作缓存。
  
  - 返回值：包含2个元素的数组，第1个为内部当前状态值，第2为更新状态值的函数。

- setXxx( ) 2种写法：
  
  - setXxx(newValue)：参数为非函数值，直接指定新的状态值，内部用其覆盖原来的状态值。
  
  - setXxx(value => newValue)：参数为函数，接收原本的状态值，返回新的状态值，内部勇气覆盖原来的状态值。

### 4. Effect Hook

- Effect Hook 可以让函数式组件中执行副作用操作（类似于类式组件的生命周期钩子）

- React中的副作用操作：

    - 发送ajax请求数据获取

    - 设置订阅 / 启动定时器

    - 手动更改真实DOM

- 语法和说明

    - ```
      componentDidMount() 钩子函数。useEffect的第二个参数为[]

      useEffect(() => {
        // 可在钩子函数进行的一系列操作
      },[])
      ```

    - ```
      componentDidUpdate() 钩子函数。useEffect的第二个参数为[stateValue](要更新的值) 

      useEffect(() => {
        // 可在钩子函数进行的一系列操作
      },[xxxx])
      ```

    - ```
      componentWillUnmount() 钩子函数。useEffect将要在第一个参数中返回需要做的一些收尾工作

      useEffect(()=> {
          return ()=> {
              // 在组件卸载之前执行，一般用于做一些收尾工作，例如清除定时器/取消订阅等等。
          }
      })
      ```

### 5. Ref Hook

- Ref Hook 可以在函数组件中存储 / 查找组件内部的标签或任意其他数据。

- 语法：```const refContainer = useRef()```

- 作用：保存标签对象，功能与 ```React.createRef()``` 一样。

------

## 4. Fragment 

### 使用

    <Fragment></Fragment>
    <></>

### 作用

> 可以不用必须有一个真实的DOM根标签

------

## 5. Context

### 理解

> 一种组件间通行方法，常用于【祖组件】 与 【后代组件】间的通信

### 使用

```js
    1) 创建Context容器对象：
        const XxxContext = React.CreateContext()
    
    2) 渲染子组件时，外面包裹XxxContext.Provider, 通过value属性给后代组件传递数据：
        <XxxContext.Provider value={数据}>
            // 子组件
        </XxxContext.Provider>

    3) 后代组件读取数据：
        // 第一种方式：仅适用于类式组件
        static contextType = xxxContent // 声明接收context
        this.context // 读取context中的value数据

        // 第二种方式：函数式组件和类式组件都能使用

        <XxxContext.Consumer>
            {
                value => (
                    // value就是context中的value数据
                    要显示的内容
                )
            }
        </XxxContext.Consumer>
```

### 注意：

> 在应用开发中一般不使用context，一般都是用它进行封装react组件

------

## 6. 组件优化

### Component的2个问题
 
- 只要执行 ```setState()``` , 即使不改变状态数据，组件也会重新 ```render() ``` ==> 效率低

- 只当前组件重新 ```render()``` , 就会自动重新 ```render``` 子组件，纵使子组件没有用到父组件的任何问题 ==> 效率低


### 效率高的做法

> 只有当组件的 state 或 props 数据发送变化时候才重新 render()


### 原因

> Component中的shouldComponentUpdate()总是返回true


### 解决

- 方法1：
  - 重写 ```shouldComponentUpdate()``` 方法。 比较新旧 state 或 props 数据，如果变化才能返回true，如果没有返回false

- 方法2:
  - 将类式组件继承 ```Component``` 改成 ```PureComponent```
    - ``` js
        export default class Xxx extends PureComponent {

        }
      ```
   
  - ```PureComponent``` 重写了 ```shouldComponentUpdate()```, 只有 state 或 props 数据有变化才会返回true
   
  - 注意：
    - 只是进行 state 和 props 数据的浅比较，如果只是数据对象内部数据变量，返回 false，需要整个对象地址发生改变才能返回 true 。

  - 项目中一般都是使用 ```PureComponent```来优化项目

-------

## 7. render props

### 如何向组件内部动态传入带内容的结构（标签）?

- Vue中：
  
    - 使用slot（插槽）技术，也就是通过组件标签体传入结构 ```<A><B/></A>```

- React中：

    - 使用 children props：通过组件标签体传入结构

    - 使用 render props：通过组件标签属性传入结构，而且可以携带参数，一般用render函数属性

### children props

```js
    <A>
        <B>hello</B>
    </A>

    <B>
        {this.props.children}
    </B>

    这样 B 组件就可以输出 hello
```

### render props

```js

    <A render={ data => <C data={data}></C>}>
    </A>

    A组件：{this.props.render(内部state数据)}
    
    C组件：读取A组件传入的数据显示 { this.props.data }
```

-------

## 8. 错误边界

- 理解：
  
  - 错误边界（Error boundary）： 用来捕获后代组件错误，渲染出备用页面。

- 特点：
  
  - 只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误。

- 使用方式：

  - getDerivedStateFromError 配合 componentDidCatch

  - ```js
        // 生命周期函数，一旦后台组件报错，就会触发。
        static getDerivedStateFromError(error) {
            console.log(error)
            // 在render之前触发 ，返回新的state
            return {
                hasError: true
            }
        }

        componentDidCatch(error, info) {
            // 统计页面的错误，发送请求送到后台去
            console.log(error, info)
        }
    ```
------



