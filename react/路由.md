# React路由

## <p></p>

## 一、SPA（单页面）的理解

###  &nbsp;&nbsp; 整个应用只是由一个完成的页面构成的，且点击页面中的链接不会刷新页面，只会做页面的局部更新。数据都需要通过 ajax 请求获取，并在前端移步展现。

## <p></p>

## 二、路由的理解

###  &nbsp;&nbsp; 什么是路由？
> 一个路由就是一个映射关系（key:value）。key为路径，value可能是function或 component 。 通俗来说就是监听页面的path路径发生改变时，去匹配对应的组件。其中path作为key，所对应的value可能function或 component。

## <p></p>

### &nbsp;&nbsp; 路由的分类

> 1. 后端路由：后端路由是一个function，用来处理客户提交的请求（router.get(path,function(req,res))）。工作过程：当node接收到一个请求时，根据请求路径找到匹配的路由，调用路由中的函数来处理请求，返回响应数据。
> 2. 前端路由：前端路由又统称为浏览器路由，是一个component，用于展示页面内容。React中注册路由的格式<Route path='/test' component={Test}> 。工作过程：当浏览器的path变为/test时，当前路由组件会变成Test组件。

### &nbsp;&nbsp; 路由的原理（案例）

## <p></p>

> 1.通过引入history.js来操作BOM元素中的浏览器记录

```
    <script src="https://cdn.bootcdn.net/ajax/libs/history/5.2.0/history.production.min.js"></script>
```
> 2.通过调用history的方法来实现路由的原理

## <p></p>

```
    let history = History.createBrowserHistory()
    // let history = History.createHashHistory()

    // 用来实现点击a标签改变path而不跳转页面
    function push(path) {
        history.push(path)
        return false
    }

    function replace(path) {
        history.replace(path)
    }
    
    function back() {
        history.goBack()
    }

    function forword(){
        history.goForward()
    }

    history.listen((localtion)=>{
        console.log('请求路由路径变化了',localtion)
    })
```

## 三、react-router-dom的理解

## <p></p>

###  &nbsp;&nbsp; 是一个react的一个插件库。专门用来实现一个SPA应用。且基于react的项目基本都会用到此库。

## <p></p>

## 四、路由的基本上使用
## <p></p>

> + 明确好界面中的导航区和内容区
> + 导航区的a标签要改为Link标签使用 
> ```
>   <Link to='/Demo'>Demo</Link>
> ```
> + 展示区写Route标签进行路径的匹配
> ```
>   // 旧版路由编写
>   <Route path='/Demo' component={Demo} />
>   <Route path='/Demo2' component={Demo2} />
> 
>   // 新版路由编写
>   <Routes>
>      <Route path='/Demo' element={<Demo/>} />
>      <Route path='/Demo2' element={<Demo2/>} />
>   </Routes>
> ```
> + 在最外层App组件上要包裹一个 BrowserRouter 或 HashRouter
> 

## <p></p>

## 五、路由组件和一般组件(适用于v6之前版本)
## <p></p>

```
    1.写法不同：
        一般组件：<Demo />
        路由组件：<Route path='/demo' component={Demo} />

    2.存放位置不同：
        一般组件：基本存放在components文件中
        路由组件：基本存放在pages文件中
    
    3.接收到的props不同（v6版本之后废弃了通过props携带参数的用法，改为hook形式的用法）：
        一般组件：写组件标签时传递了什么，就能通过props接收到什么
        路由组件：接收到三个固定的属性：
            history:
                go: f go(n)
                goBack: f goBack()
                goForward: f goForward()
                push: f push(path,state)
                replace: f push(path,state)
            location:
                pathname: '/xxxx'
                search: ''
                state: ''
            match:
                params: {}
                path: ''
                url: ''

```
## <p></p>

## 六、NavLink和封装NavLink 
## <p></p>

> + NavLink 可以实现路由链接的高亮显示，通过activeClassName属性来指定样式名
> + 标签体内容是一个特殊的标签属性
> + 通过 this.props.children可以获取标签体内容
## <p></p>

## 七、Switch的使用
## <p></p>

> + 通常情况下，path和component是一一对应的关系
> + Switch可以提高路由的匹配效率（实现单一匹配）
> + 在新版（v6）路由中，Switch被替换了Routes
## <p></p>

## 八、解决多极路由刷新页面样式丢失问题
## <p></p>

> + public/index.html 文件中引入样式时不写 './' 写 '/'
> + public/index.html 文件中引入样式时不写 './' 写 %PUBLIC_URL%
> + 使用HashRouter
## <p></p>

## 九、路由的模糊匹配和严格匹配，以及路由重定向的使用

## <p></p>

> + 默认使用的是模糊匹配（输入的路径必须包含要匹配的路径，且顺序一致）
> + 开启严格匹配 在Route 标签中添加属性 exact
> + 严格匹配不需要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由
> + 重定向路由一般写在所以路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由
> ```
>   <Switch>
>    <Route path='/Demo' component={Demo}/>
>    <Route path='/Demo1' component={Demo1}/>
>    <Redirect to='/Demo'>
>    // 新版本中的路由替换为
>   <Route path='*' element={<Nagive to='/Demo'>} />
>   </Switch>
> ```
## <p></p>

## 十、路由传参的三种方式(包含v6版本的使用)
## <p></p>
### 1.通过params方式参数传参

```
    import React,{ Component } from 'react'
    import { Link,Routes,Route ,Switch}
    import Detail from './Detail'

    export default class Message extends Compoment {
        state={
            messageArr:[
                {id:'1',title:'消息1'},
                {id:'2',title:'消息2'},
                {id:'3',title:'消息3'}
            ]
        }
        render(){
            const { messageArr } = this.state
            return (
                <div>
                    <ul>
                        {
                            messageArr.map(messageObj => (
                                <li key={messageObj.id}>
                                    <Link to={`detail/${messageObj.id}/${messageObj.title}`}>{messageObj.title}</Link>
                                </li>
                            ))
                        }             
                    </ul>
                    <hr />
                    // v5 写法 Switch
                    <div>
                        <Switch>
                            <Route path="detail/:id/:title" conmponent={Detai} />
                        </Switch>
                    </div>
                    // v6 写法 Routes
                    <div>
                        <Routes>
                            <Route path="detail/:id/:title" element={<Detai />} />
                        </Routes>
                    </div>
                </div>
            )
        }
    }

```

```
    // v5 接收params参数用法
    import React,{ Component } from 'react'
    const detals = [
        {
            id: 1,
            content: '测试1'
        },
        {
            id: 2,
            content: '测试2'
        },
        {
            id: 3,
            content: '测试3'
        },
        {
            id: 4,
            content: '测试4'
        }
    ]
    export default class Detai extends Compoment {
        render(){
            const { id,title } = this.props.math.params
            const findResult = detals.find(item => item.id === +id)
            renturn(
                <ul>
                    <li>
                        id: {id}
                    </li>
                    <li>
                        title: {title}
                    </li>
                    <li>
                        content: {findResult.content || ''}
                    </li>
                </ul>
            )
        }
    }
```
```
    // v6 接收params参数用法
    import React from 'react';
    import { useParams } from 'react-router-dom'
    // 这里定义函数式组件，v6版本的useParams不支持在类式组件中使用
    export default function Detail() {
        const detals = [
            {
                id: 1,
                content: '测试1'
            },
            {
                id: 2,
                content: '测试2'
            },
            {
                id: 3,
                content: '测试3'
            },
            {
                id: 4,
                content: '测试4'
            }
        ]
        const params = useParams()
        const findResult = detals.find(item => item.id === +params.id)
        return(
            <ul>
                <li>
                    id: {params.id}
                </li>
                <li>
                    title: {params.title}
                </li>
                <li>
                    content: {findResult.content || ''}
                </li>
            </ul>
        )
    }
```
## <p></p>

### 2.通过search方式参数传参
## <p></p>

```
    // 调用形式
    <Link to={`detail?id=${messageObj.id}&title=${messageObj.title}`}>{messageObj.title}</Link>

    // 接收形式
    // v5 写法 Switch
        <Switch>
            <Route path="detail" conmponent={Detai} />
        </Switch>
    // v6 写法 Routes
        <Routes>
            <Route path="detail" element={<Detai />} />
        </Routes>
```
```
    // v5 接收search参数用法
    import React,{ Component } from 'react'
    import qs from 'querystring'
    const detals = [
        {
            id: 1,
            content: '测试1'
        },
        {
            id: 2,
            content: '测试2'
        },
        {
            id: 3,
            content: '测试3'
        },
        {
            id: 4,
            content: '测试4'
        }
    ]
    export default class Detai extends Compoment {
        render(){
            const { search } = this.props.location
            // 接收到的search = '?id=xxx&title=xxx'
            const {id,title} = qs.parse(search.slice(1))
            const findResult = detals.find(item => item.id === +id)
            renturn(
                <ul>
                    <li>
                        id: {id}
                    </li>
                    <li>
                        title: {title}
                    </li>
                    <li>
                        content: {findResult.content || ''}
                    </li>
                </ul>
            )
        }
    }
```
```
    // v6 接收search参数用法
    import React from 'react';
    import { useSearchParams } from 'react-router-dom'
    // 这里定义函数式组件，v6版本的useSearchParams不支持在类式组件中使用
    export default function Detail() {
        const detals = [
            {
                id: 1,
                content: '测试1'
            },
            {
                id: 2,
                content: '测试2'
            },
            {
                id: 3,
                content: '测试3'
            },
            {
                id: 4,
                content: '测试4'
            }
        ]
        const [search] = useSearchParams()
        const id = search.get('id')
        const title = search.get('title')
        const findResult = detals.find(item => item.id === +id)
        return(
            <ul>
                <li>
                    id: {id}
                </li>
                <li>
                    title: {title}
                </li>
                <li>
                    content: {findResult.content || ''}
                </li>
            </ul>
        )
    }
```
## <p></p>

### 3.通过state方式参数传参
## <p></p>

```
    // 调用形式
    <Link to='detail' state={id:'messageObj.id',title:'messageObj.title'}>{messageObj.title}</Link>

    // 接收形式
    // v5 写法 Switch
        <Switch>
            <Route path="detail" conmponent={Detai} />
        </Switch>
    // v6 写法 Routes
        <Routes>
            <Route path="detail" element={<Detai />} />
        </Routes>
```
```
    // v5 接收state参数用法
    import React,{ Component } from 'react'
    const detals = [
        {
            id: 1,
            content: '测试1'
        },
        {
            id: 2,
            content: '测试2'
        },
        {
            id: 3,
            content: '测试3'
        },
        {
            id: 4,
            content: '测试4'
        }
    ]
    export default class Detai extends Compoment {
        render(){
            const {id,title} = this.props.location.state || {}
            const findResult = detals.find(item => item.id === +id)
            renturn(
                <ul>
                    <li>
                        id: {id}
                    </li>
                    <li>
                        title: {title}
                    </li>
                    <li>
                        content: {findResult.content || ''}
                    </li>
                </ul>
            )
        }
    }
```
```
    // v6 接收search参数用法
    import React from 'react';
    import { useLocation } from 'react-router-dom'
    // 这里定义函数式组件，v6版本的useLocation不支持在类式组件中使用
    export default function Detail() {
        const detals = [
            {
                id: 1,
                content: '测试1'
            },
            {
                id: 2,
                content: '测试2'
            },
            {
                id: 3,
                content: '测试3'
            },
            {
                id: 4,
                content: '测试4'
            }
        ]
        const {id,title} = useLocation().state || {}
        const findResult = detals.find(item => item.id === +id)
        return(
            <ul>
                <li>
                    id: {id}
                </li>
                <li>
                    title: {title}
                </li>
                <li>
                    content: {findResult.content || ''}
                </li>
            </ul>
        )
    }
```
## <p></p>

## 十一、编程式路由导航
## <p></p>
### v5版本之前 
> + this.props.history.push()
> + this.props.history.replcae()
> + this.props.history.go()
> + this.props.history.goBack()
> + this.props.history.goForward()
### v6版本
```
    import { useNavigate } from 'react-router-dom'

    function Test () {
        let navigate = useNavigate()
        navigate('/xxxx')
        navigate('/xxxx',{replace:true})
        navigate(1)
        navigate(-1)
        ....
    }
```
## <p></p>

## 十二、withRouter 
## <p></p>

### &nbsp;&nbsp; withRouter 可以加工一般组件，让一般组件具备路由组件所持有的所有API。 withRouter的返回值是一个新组件
### &nbsp;&nbsp; 在v6版本用可以直接使用useNavigate来获取编程式组件的方法


